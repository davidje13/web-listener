import { open, readdir, realpath, stat, type FileHandle } from 'node:fs/promises';
import { basename, dirname, join, resolve, sep } from 'node:path';
import { constants, type Stats } from 'node:fs';
import { internalOverrideFlags } from '../../util/regexpFlags.mts';
import { Queue } from '../../util/Queue.mts';
import {
  makeNegotiator,
  type FileNegotiation,
  type NegotiationInput,
  type NegotiationOutputInfo,
  type Negotiator,
} from '../request/negotiation.mts';

export interface FileFinderOptions {
  /**
   * Also serve files from sub-directories.
   * Can be set to a number to control the depth of subdirectories served (where 0 means no
   * subdirectories).
   *
   * @default true
   */
  subDirectories?: boolean | number | undefined;

  /**
   * Configure case sensitivity of paths.
   *
   * `exact`: ensure that the path exactly matches the filesystem, even if the filesystem
   * itself is case insensitive.
   *
   * `filesystem`: use the case sensitivity of the filesystem.
   *
   * `force-lowercase`: lowercase all requests before forwarding to the filesystem (this
   * can achieve case insensitivity on otherwise case sensitive filesystems, but only if
   * all files and folders are stored as lowercase).
   *
   * @default 'exact'
   */
  caseSensitive?: 'exact' | 'filesystem' | 'force-lowercase' | undefined;

  /**
   * Allow serving dotfiles.
   * If `true`, all dotfiles will be available (note this can be a security risk if you have
   * sensitive hidden files or directories in the directory being served, such as `.git`).
   * If you only need some dotfiles to be made available, you can use `permit` instead, which
   * lets you allow specific file / directory names.
   *
   * @default false
   */
  allowAllDotfiles?: boolean | undefined;

  /**
   * Allow serving files which begin or end with a tilde.
   * These are commonly backup files (e.g. generated by vim when editing a file), and may or
   * may not be a security risk to expose, depending on your setup.
   * If `true`, all tilde files will be available.
   * If you only need some tilde files to be made available, you can use `permit` instead, which
   * lets you allow specific file / directory names.
   *
   * @default false
   */
  allowAllTildefiles?: boolean | undefined;

  /**
   * Serve index files when requested directly (e.g. `/foo/index.htm`).
   * By default, index files (listed in `indexFiles`) are only served if the directory is requested.
   *
   * @default false
   */
  allowDirectIndexAccess?: boolean | undefined;

  /**
   * Hide arbitrary files from direct access. For example, when supporting content negotiation
   * you may wish to block direct access to the "negotiated" variants of files such as `/\.gz$/`.
   *
   * Matches are performed on each path component. If any match, the file is hidden. Regular
   * expressions are automatically made case insensitive if `caseSensitive` is `'filesystem'` or
   * `'force-lowercase'`
   *
   * In cases where both match the same path component, `allow` overrides `hide`.
   *
   * @default []
   */
  hide?: (string | RegExp)[] | undefined;

  /**
   * Allow access to specific files which would otherwise be blocked as a dotfile, tilde file, or
   * hidden by `hide`.
   *
   * @default ['.well-known']
   */
  allow?: string[] | undefined;

  /**
   * Files to look for if a directory is requested.
   * Note that direct access to these files will be blocked unless `allowDirectIndexAccess` is `true`.
   *
   * If an empty list is provided, no index files will be served.
   *
   * @default ['index.htm', 'index.html']
   */
  indexFiles?: string[] | undefined;

  /**
   * Suffixes to try appending if the requested file does not exist.
   *
   * For example, specifying `['.html']` will serve `foo.html` at `/foo`
   *
   * @default []
   */
  implicitSuffixes?: string[] | undefined;

  /**
   * Content negotiation rules to apply to files.
   *
   * This can be used to respond to the `Accept`, `Accept-Language`, and `Accept-Encoding` headers.
   *
   * For example: on a server with `foo.txt`, `foo.txt.gz`, and a negotiation rule mapping
   * `gzip` => `{name}.gz`:
   * - users requesting `foo.txt` may get `foo.txt.gz` with `Content-Encoding: gzip` if their
   *   client supports gzip encoding
   * - users requesting `foo.txt` may get `foo.txt` with no `Content-Encoding` if their client
   *   does not support gzip encoding
   *
   * Note that file access is checked *before* content negotiation, so you must still provide a
   * base "un-negotiated" file for each file you wish to serve (which will also be used in cases
   * where users do not send any `Accept-*` headers, and where no match is found)
   *
   * Multiple rules can match simultaneously, if a specific enough file exists (for example you might
   * have `foo-en.txt.gz` for `Accept-Language: en` and `Accept-Encoding: gzip`).
   *
   * In the case of conflicting rules, earlier rules take priority (so `encoding` rules should
   * typically be specified last)
   *
   * See the helper `negotiateEncoding` for a simple way to support pre-compressed files.
   *
   * @default []
   */
  negotiation?: FileNegotiation[] | undefined;
}

export interface FileFinderCore {
  find(pathParts: string[], negotiation?: NegotiationInput): Promise<ResolvedFileInfo | null>;
  readonly vary: string;
}

export class FileFinder implements FileFinderCore {
  /** @internal */ declare private readonly _basePath: string;
  /** @internal */ declare private readonly _subDirectories: number;
  /** @internal */ declare private readonly _caseSensitive:
    | 'exact'
    | 'filesystem'
    | 'force-lowercase';
  /** @internal */ declare private readonly _allowAllDotfiles: boolean;
  /** @internal */ declare private readonly _allowAllTildefiles: boolean;
  /** @internal */ declare private readonly _allowDirectIndexAccess: boolean;
  /** @internal */ declare private readonly _allow: Set<string>;
  /** @internal */ declare private readonly _hide: Set<string>;
  /** @internal */ declare private readonly _hidePattern: RegExp[];
  /** @internal */ declare private readonly _indexFiles: string[];
  /** @internal */ declare private readonly _indexFilesSet: Set<string>;
  /** @internal */ declare private readonly _implicitSuffixes: string[];
  /** @internal */ declare private readonly _negotiator: Negotiator | undefined;
  declare public readonly vary: string;

  /** @internal */
  private constructor(
    basePath: string,
    {
      subDirectories = true,
      caseSensitive = 'exact',
      allowAllDotfiles = false,
      allowAllTildefiles = false,
      allowDirectIndexAccess = false,
      allow = ['.well-known'],
      hide = [],
      indexFiles = ['index.htm', 'index.html'],
      implicitSuffixes = [],
      negotiation,
    }: FileFinderOptions,
  ) {
    this._basePath = basePath;
    this._subDirectories = subDirectories === true ? Number.POSITIVE_INFINITY : subDirectories || 0;
    this._caseSensitive = caseSensitive;
    this._allowAllDotfiles = allowAllDotfiles;
    this._allowAllTildefiles = allowAllTildefiles;
    this._allowDirectIndexAccess = allowDirectIndexAccess;
    this._indexFiles = indexFiles;
    this._implicitSuffixes = ['', ...implicitSuffixes];

    this._allow = new Set(allow.map((v) => this._normalise(v)));
    this._hide = new Set();
    this._hidePattern = [];
    for (const item of hide) {
      if (typeof item === 'string') {
        this._hide.add(this._normalise(item));
      } else {
        this._hidePattern.push(internalOverrideFlags(item, !caseSensitive));
      }
    }
    this._indexFilesSet = new Set(indexFiles.map((f) => this._normalise(f)));

    if (negotiation?.length) {
      this._negotiator = makeNegotiator(negotiation);
      this.vary = this._negotiator.vary;
    } else {
      this.vary = '';
    }
  }

  static async build(absBasePath: string, options: FileFinderOptions) {
    return new FileFinder((await realpath(absBasePath, { encoding: 'utf-8' })) + sep, options);
  }

  /** @internal */
  private _normalise(part: string) {
    return this._caseSensitive === 'exact' ? part : part.toLowerCase();
  }

  /** @internal */
  private _checkPermitted(normed: string) {
    if (this._allow.has(normed)) {
      return true;
    }
    const trimmed = normed.trim(); // Windows may trim spaces from filenames
    if ((trimmed[0] === '~' || trimmed[trimmed.length - 1] === '~') && !this._allowAllTildefiles) {
      return false;
    } else if (trimmed[0] === '.' && !this._allowAllDotfiles) {
      return false;
    } else if (this._hide.has(trimmed) || this._hidePattern.some((p) => p.test(trimmed))) {
      return false;
    } else {
      return true;
    }
  }

  /**
   * Find a file which matches the path.
   *
   * Note that the returned value contains an active `FileHandle`, which must be closed.
   *
   * @param pathParts the request path, split into separate components
   * @param negotiation any client-sent negotiation options to apply
   * @returns details about the resolved file (including an active `FileHandle`), or `null`
   */
  async find(
    pathParts: string[],
    negotiation: NegotiationInput = {},
  ): Promise<ResolvedFileInfo | null> {
    let subPath = pathParts.join(sep);
    if (this._caseSensitive === 'force-lowercase') {
      subPath = subPath.toLowerCase();
    }
    let resolvedPath = resolve(this._basePath, subPath);
    if (!resolvedPath.startsWith(this._basePath) && resolvedPath + sep !== this._basePath) {
      return null; // directory traversal escaped root directory: fail
    }

    let parts: string[] | null = null;
    let realPath: string | null = null;
    for (const suffix of this._implicitSuffixes) {
      const suffixedPath = resolvedPath + suffix;
      parts = suffixedPath
        .substring(this._basePath.length)
        .split(sep)
        .filter((part) => part);
      if (parts.length > this._subDirectories + 1) {
        return null; // requested path is too deep for our config: fail
      }
      if (parts.some((p) => !this._checkPermitted(this._normalise(p)))) {
        return null; // part of the requested path involves a file which we do not permit access to: fail
      }
      const name = parts[parts.length - 1] ?? '';
      if (
        !this._allowDirectIndexAccess &&
        this._indexFilesSet.has(this._normalise(name)) &&
        !this._allow.has(this._normalise(name))
      ) {
        return null; // requested an index file by name, denied by config: fail
      }
      realPath = await realpath(suffixedPath, { encoding: 'utf-8' }).catch(() => null);
      if (realPath) {
        resolvedPath = suffixedPath;
        break;
      }
    }
    if (!realPath || !parts) {
      // requested path does not exist: fail
      return null;
    }
    if (this._normalise(realPath) !== this._normalise(resolvedPath)) {
      // real path turned out to be different (e.g. a symlink): fail
      return null;
    }

    let canonicalPath = realPath;
    let stats = await stat(realPath).catch(() => null);
    if (!stats) {
      return null; // requested path does not exist: fail
    }
    if (stats.isDirectory()) {
      if (parts.length > this._subDirectories) {
        return null; // requested path is a directory and is too deep for our config to look for an index file: fail
      }
      for (const attempt of this._indexFiles) {
        const indexPath = join(realPath, attempt);
        stats = await stat(indexPath).catch(() => null);
        if (stats?.isFile()) {
          canonicalPath = indexPath;
          break;
        }
      }
    }
    if (!stats?.isFile()) {
      return null; // requested path exists but is not a regular file: fail
    }
    if (this._negotiator) {
      const base = basename(canonicalPath);
      const dir = dirname(canonicalPath);
      for (const option of this._negotiator.options(base, negotiation)) {
        if (!option.filename || option.filename.includes(sep)) {
          continue;
        }
        const result = await internalTryReturn({
          canonicalPath,
          negotiatedPath: join(dir, option.filename),
          ...option.info,
        });
        if (result) {
          return result;
        }
      }
    }
    return internalTryReturn({ canonicalPath, negotiatedPath: canonicalPath });
  }

  async precompute(): Promise<FileFinderCore> {
    const lookup = new Map<string, StaticFileInfo>();
    const set = (path: string, info: StaticFileInfo) => {
      const existing = lookup.get(path);
      if (!existing || info.p > existing.p) {
        lookup.set(path, info);
      }
    };
    const queue = new Queue({ dir: [this._basePath], depth: 0 });
    for (const { dir, depth } of queue) {
      const dirEntries = await readdir(join(...dir), { withFileTypes: true, encoding: 'utf-8' });
      const siblings = new Set(dirEntries.map((v) => this._normalise(v.name)));
      for (const file of dirEntries) {
        const normFileName = this._normalise(file.name);
        if (!this._checkPermitted(normFileName)) {
          continue;
        }
        const path = [...dir, file.name];
        if (file.isDirectory()) {
          if (depth < this._subDirectories) {
            queue.push({ dir: path, depth: depth + 1 });
          }
          set(this._normalise(path.slice(1).join('/')), DIR);
        } else if (file.isFile()) {
          const entity: Omit<StaticFileInfo, 'p'> = {
            file: join(...path),
            dir: join(...dir),
            basename: normFileName,
            siblings,
          };
          const indexPos = this._indexFiles.indexOf(normFileName);
          if (indexPos !== -1) {
            set(this._normalise(dir.slice(1).join('/')), {
              ...entity,
              p: this._indexFiles.length + 1 - indexPos,
            });
            if (!this._allowDirectIndexAccess && !this._allow.has(normFileName)) {
              continue;
            }
          }
          const fullPath = this._normalise(path.slice(1).join('/'));
          for (let i = 0; i < this._implicitSuffixes.length; ++i) {
            const suffix = this._implicitSuffixes[i]!;
            if (file.name.endsWith(suffix)) {
              set(fullPath.substring(0, fullPath.length - suffix.length), { ...entity, p: -i });
            }
          }
        }
      }
    }

    return {
      find: async (path, negotiation = {}) => {
        const entity = lookup.get(this._normalise(path.join('/')));
        if (!entity?.file) {
          return null;
        }
        if (this._negotiator) {
          for (const option of this._negotiator.options(entity.basename, negotiation)) {
            if (!entity.siblings.has(this._normalise(option.filename))) {
              continue;
            }
            const result = await internalTryReturn({
              canonicalPath: entity.file,
              negotiatedPath: join(entity.dir, option.filename),
              ...option.info,
            });
            if (result) {
              return result;
            }
          }
        }
        return internalTryReturn({
          canonicalPath: entity.file,
          negotiatedPath: entity.file,
        });
      },
      vary: this.vary,
    };
  }
}

export interface ResolvedFileInfo extends NegotiationOutputInfo {
  /** An active filehandle for the resolved file. Note that this MUST be closed by the caller. */
  handle: FileHandle;
  /** The full path of the requested file (after adding implicit extensions and index files) */
  canonicalPath: string;
  /** The full path of the resolved file (which may differ from canonicalPath by including e.g. `.gz` if gzip encoding was negotiated) */
  negotiatedPath: string;
  /** Filesystem stats about the resolved file */
  stats: Stats;
}

interface StaticFileInfo {
  file: string;
  dir: string;
  basename: string;
  siblings: Set<string>;
  p: number;
}

const DIR: StaticFileInfo = { file: '', dir: '', basename: '', siblings: new Set(), p: 1 };

async function internalTryReturn(
  details: Omit<ResolvedFileInfo, 'handle' | 'stats'>,
): Promise<ResolvedFileInfo | null> {
  const handle = await open(details.negotiatedPath, constants.O_RDONLY).catch(() => null);
  if (!handle) {
    return null;
  }
  const fail = () => {
    handle.close().catch(() => {});
    return null;
  };
  // open() also succeeds for directories and various other
  // types of node, so we must confirm this is a file:
  const stats = await handle.stat().catch(fail);
  if (!stats?.isFile()) {
    return fail();
  }
  return { handle, stats: stats, ...details };
}
